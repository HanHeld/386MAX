          title     BATERRS - BATPROC error messages

          page      ,132                ;make wide listing

          comment   }

          (C) Copyright 1990, Rex Conn for Qualitas  GNU General Public License version 3

          This module includes error message tables and routines to access
          them.  The two routines are accessible from assembler (ERRMSGA)
          or c (_errmsgc).  They return a far pointer to the message; if
          the message is not found a pointer to a message reading
          "unknown error" is returned.

          The internal routine ERRFIND may also be called externally.  It
          returns a pointer into a table supplied by the caller.

          } end description

          ;
          ; Includes
          ;
          include   macros.asm           ;general macros
          ;

_TEXT     segment   byte public 'CODE'  ;define code segment (no data)

          assume    cs:_TEXT, ds:nothing, ss:nothing, es:nothing  

msgtable  label     byte                ;beginning of message table
          ;
          ; Basic errors
          ;
          defmsg    1,<"Bad function">
          defmsg    2,<"File not found">
          defmsg    3,<"Invalid path">
          defmsg    4,<"Too many open files">
          defmsg    5,<"Access denied">
          defmsg    6,<"Invalid handle">
          defmsg    7,<"Memory destroyed">
          defmsg    8,<"Out of memory">
          defmsg    9,<"Bad memory block">
          defmsg    10,<"Bad environment">
          defmsg    11,<"Bad format">
          defmsg    12,<"Invalid access code">
          defmsg    13,<"Invalid data">
          defmsg    14,<"Internal DOS error">
          defmsg    15,<"Invalid drive">
          defmsg    16,<"Can't remove current directory">
          defmsg    17,<"Not same device">
          defmsg    18,<"File not found">
          ;
          ; DOS INT 24 (critical error) messages 
          ;
          defmsg    19,<"Disk is write protected">
          defmsg    20,<"Bad disk unit">
          defmsg    21,<"Drive not ready--close door">
          defmsg    22,<"Bad disk command">
          defmsg    23,<"Data error">
          defmsg    24,<"Bad call format">
          defmsg    25,<"Seek error">
          defmsg    26,<"Non-DOS disk">
          defmsg    27,<"Sector not found">
          defmsg    28,<"Out of paper">
          defmsg    29,<"Write error">
          defmsg    30,<"Read error">
          defmsg    31,<"General failure">

          ;
          ; DOS 3 extended errors (mostly network errors)
          ;   used for error messages generated by 4DOS INT 24 handler
          ;
          defmsg    32,<"Sharing violation">
          defmsg    33,<"Lock violation">
          defmsg    34,<"Invalid disk change">
          defmsg    35,<"FCB unavailable">
          defmsg    36,<"Sharing buffer overflow">
          defmsg    40,<"Not ready">
          defmsg    41,<"File Allocation Table bad">
          defmsg    50,<"Invalid net request">
          defmsg    51,<"Remote computer not listening">
          defmsg    52,<"Duplicate name on net">
          defmsg    53,<"Net name not found">
          defmsg    54,<"Net busy">
          defmsg    55,<"Net device no longer exists">
          defmsg    56,<"NetBIOS command limit exceeded">
          defmsg    57,<"Net adapter hardware error">
          defmsg    58,<"Bad response from net">
          defmsg    59,<"Unexpected net error">
          defmsg    60,<"Incompatible remote adapter">
          defmsg    61,<"Print queue full">
          defmsg    62,<"Queue not full">
          defmsg    63,<"No room for print file">
          defmsg    64,<"Net name was deleted">
          defmsg    65,<"Access denied">
          defmsg    66,<"Net device type incorrect">
          defmsg    67,<"Net name not found">
          defmsg    68,<"Net name limit exceeded">
          defmsg    69,<"NetBIOS session limit exceeded">
          defmsg    70,<"Temporarily paused">
          defmsg    71,<"Net request not accepted">
          defmsg    72,<"Redirection is paused">
          defmsg    80,<"File exists">
          defmsg    82,<"Can't make directory entry">
          defmsg    83,<"Fail on INT 24">
          defmsg    84,<"Too many redirections">
          defmsg    85,<"Duplicate redirection">
          defmsg    86,<"Invalid password">
          defmsg    87,<"Invalid parameter">
          defmsg    88,<"Net device fault">

          db        0, 0FFh                       ;end of table

undef     db        udlen, "Undefined error"      ;message if not found
udlen     equ       $ - undef - 1


          ;
          ; ERRMSGC - Error message routine callable from C
          ;
          ; On entry:
          ;         Argument on stack using pascal calling convention:
          ;            int errnum:      error number
          ;
          ; On exit:
          ;         DX:AX = address of message
          ;         All other registers and interrupt state unchanged
          ;

          entry     errmsgc,argframe    ; set up entry point

          argW      errnum              ; error number

          pushm     si,ds               ; save registers
          mov       ax,errnum           ; get error number
          call      errmsga             ; let assembler routine do the work
          mov       dx,ds               ; copy segment
          mov       ax,si               ; copy offset
          popm      ds,si               ; restore registers
          exit


          ;
          ; ERRMSGA - Error message routine callable from assembler
          ;
          ; On entry:
          ;         AL = error number
          ;
          ; On exit:
          ;         Carry set if message not found, clear if found
          ;         DS:SI = message address (length byte) if found
          ;         All other registers and interrupt state unchanged
          ;

          entry     errmsga,noframe     ; find error message, return pointer

          mov       si,cs               ; get segment where message is
          mov       ds,si               ; copy for scan and return
          lea       si,msgtable         ; point to message table
          call      ErrFind             ; find the message
          jnc       return              ; if it was found we're done
          lea       si,undef            ; not found - use undefined error msg
          stc                           ; be sure carry is set

return:
          exit


          ;
          ; ERRFIND - Error message finder
          ;
          ; On entry:
          ;         AL = error number
          ;         DS:SI = address of error message table
          ;
          ; On exit:
          ;         Carry set if message not found, clear if found
          ;         DS:SI = message address (length byte) if found
          ;         All other registers and interrupt state unchanged
          ;

          entry     errfind,noframe     ;find error message, return pointer

          push      cx                  ;save cx

msgloop:  mov       cx,[si]             ;get number (cl) and text length (ch)
          cmp       cl,0FFh             ;last message?
          je        notfound            ;yes, error
          cmp       al,cl               ;is this what we want?
          je        foundmsg            ;yes, go on
          mov       cl,ch               ;get text length in cl
          xor       ch,ch               ;clear high byte
          add       si,cx               ;skip text
          add       si,2                ;skip message number and length
          jmp       short msgloop       ;keep trying

notfound: stc                           ;not found - show error
          jmp       short findret       ;all done

foundmsg: inc       si                  ;found it -- point to length byte
          clc                           ;clear carry

findret:  pop       cx                  ;restore cx
          exit

_TEXT     ends

          end

