//' $Header:   P:/PVCS/MAX/GOAHEAD/GOAHEAD.C_V   1.12   10 Jul 1996 11:03:58   BOB  $
//
//***************************************************************************
//	Module:   GOAHEAD.C
//
//	Purpose:
//	Simple Windows application which provides graphical interface
//	to managing GOAHEAD.DRV, the associated installable driver.
//
//***************************************************************************


#include <windows.h>
#include <stdlib.h>
#include <ctl3d.h>
#include <ver.h>
#include <winternl.h>

// File I/O includes
#include <io.h>
#include <fcntl.h>
#include <sys\stat.h>

// Private include files
#include "goahead.h"            // specific to this program
#include "resapp.h"             // resource header generated by AppStudio

#define WHITE	RGB(255, 255, 255)
#define BLUE	RGB(  0,   0, 255)
#define GREEN	RGB(  0, 255,	0)
#define RED	RGB(255,   0,	0)
#define YELLOW	RGB(255, 255,	0)

extern const HINSTANCE _hInstance;	// supplied by C RunTime startup code
extern const HINSTANCE _hPrevInstance;	// ditto

char szAppDPFE[_MAX_PATH]; // .EXE drive, path, filename.exe
char szHlpDPFE[_MAX_PATH]; // .HLP drive, path, filename.hlp
char szDrvDPFE[_MAX_PATH]; // .DRV drive, path, filename.drv
DWORD dwTotal;		// Total # free bytes
HICON hIconGo,		// Our icon handle when enabled
	  hIconStop,	// ...					disabled
	  hIconCur;	// Current icon
WORD wVer;			// Windows version in comparison order
WORD wEnableState,	// Enable/disable state:
					// The result is 0 if enabled, 1 if disabled by command,
					//		 2 if disabled by program, 3 if disabled by failsafe
	 wOldEnableState = (WORD) -1; // Previous state so we can tell when it has changed
WORD xPosCtr, yPosCtr;	// x- and y- center of window positions
WORD xSize, ySize;	// x- and y- size in screen coordinates
BOOL fHelp = FALSE; // TRUE if we displayed help
BOOL fLoaded = FALSE;	// TRUE if driver is loaded at boot time, otherwise FALSE
BOOL fOntop = FALSE; // Always on top flag
BOOL fRID = FALSE;	// TRUE if Read Incompat Driver dialog called
DWORD dwSizeDOS=1,	// Size of DOS in bytes = (640KB - lowest_free_segment)
	  dwTaskCnt;		// # active tasks
RECT rcMemBar,		// Client rectangle for the low DOS memory bar
	 rcIcon1;		// ...						icon in the main window
DWORD dwMemBarWidth; // Width of the low DOS memory bar
int nMinState;		// Initial state (minimized or maximized)
HWND hMemBar,		// The low DOS memory bar handle
	 hDlgBox;		// Modeless dialog box handle
FARPROC lpfnOldEB;	// Save area for old Edit Box procedure
PSTR pszOpenName;	// Ptr to filename used to open the driver
PSTR pVerDrv, pVerApp; // Ptrs to driver and application version information

typedef struct		// Free low DOS memory
{
	WORD Seg,		// Segment
	 Sel,		// Selector
	 ELen,		// Length in paras
	 TLen,		// Total length in paras including following adjacent entries
	 Adj;		// # adjacent following entries, 0 = none
} FAR * LPDOSMEM;

char szDrive[_MAX_DRIVE],
	 szDir[_MAX_DIR],
	 szFname[_MAX_FNAME],
	 szExt[_MAX_EXT];

typedef struct
{
	char **ppLS;
	WORD wRes;

} LPLS;

PSTR pszCaptionMax,
	 pszCaptionMinEna,
	 pszCaptionMinDis,
	 pszCaptionMinEna95,
	 pszCaptionMinDis95,
	 pszCaptionUnl,
	 pszStatusEna,
	 pszStatusDis,
	 pszStatusUnl,
	 pszHelpKeyMain,
	 pszHelpKeyProg,
	 pszHelpKeyOverview,
	 pszHelpKeyTechSupp,
	 pszLeadSN,
	 pszTaskCnt,
	 pszNoRegClass,
	 pszNoCreateDlgMain,
	 pszNoCreateDlgProg,
	 pszMenuAbout,
	 pszMenuOntop,
	 pszMenuOverview,
	 pszMenuSearch,
	 pszMenuTechSupp,
	 pszNoFindDrvr,
	 pszButtonEnable,
	 pszButtonDisable,
	 pszNoCloseDrvr,
	 pszNoOpenDrvr,
	 pszTotMem,
	 pszFreeMem,
	 pszMemTextDisabledProg,
	 pszMemTextDisabledCmd,
	 pszMemTextDisabledFail,
	 pszMemTextDisabledRID,
	 pszMemTextNotloaded,
	 pszDebugDOSMem,
	 pszDebugTotal,
	 pszNoWriteINIFile,
	 pszINIFileName,
	 pszINISectName,
	 pszINICFGSect,
	 pszINIMAXPath,
	 pszINIMAXHelp,
	 pszINILineName,
	 pszINIProgSect,
	 pszINIGenSect,
	 pszINIXPosName,
	 pszINIYPosName,
	 pszINIOntopName,
	 pszINIRegSect,
	 pszINIRegName,
	 pszINIRegCompany,
	 pszINIRegSN,
	 pszAppName,
	 pszDrvName,
	 pszFileClass,
	 pszGADialog,
	 pszVersionMismatch,
	 pszVersion;

LPLS pLS[] = {{&pszCaptionMax,			IDS_CAPTIONMAX},
			  {&pszCaptionMinEna,		IDS_CAPTIONMINENA},
			  {&pszCaptionMinDis,		IDS_CAPTIONMINDIS},
			  {&pszCaptionMinEna95, 	IDS_CAPTIONMINENA95},
			  {&pszCaptionMinDis95, 	IDS_CAPTIONMINDIS95},
			  {&pszCaptionUnl,			IDS_CAPTIONUNL},
			  {&pszStatusEna,			IDS_STATUSENA},
			  {&pszStatusDis,			IDS_STATUSDIS},
			  {&pszStatusUnl,			IDS_STATUSUNL},
			  {&pszHelpKeyMain,		IDS_HELPKEYMAIN},
			  {&pszHelpKeyProg,		IDS_HELPKEYPROG},
			  {&pszHelpKeyOverview, 	IDS_HELPKEYOVERVIEW},
			  {&pszHelpKeyTechSupp, 	IDS_HELPKEYTECHSUPP},
			  {&pszLeadSN,				IDS_LEADSN},
			  {&pszTaskCnt, 			IDS_TASKCNT},
			  {&pszNoRegClass,			IDS_NOREGCLASS},
			  {&pszNoCreateDlgMain, 	IDS_NOCREATEDLGMAIN},
			  {&pszNoCreateDlgProg, 	IDS_NOCREATEDLGPROG},
			  {&pszMenuAbout,			IDS_MENUABOUT},
			  {&pszMenuOntop,			IDS_MENUONTOP},
			  {&pszMenuOverview,		IDS_MENUOVERVIEW},
			  {&pszMenuSearch,			IDS_MENUSEARCH},
			  {&pszMenuTechSupp,		IDS_MENUTECHSUPP},
			  {&pszNoFindDrvr,			IDS_NOFINDDRVR},
			  {&pszButtonEnable,		IDS_BUTTONENABLE},
			  {&pszButtonDisable,		IDS_BUTTONDISABLE},
			  {&pszNoCloseDrvr,		IDS_NOCLOSEDRVR},
			  {&pszNoOpenDrvr,			IDS_NOOPENDRVR},
			  {&pszTotMem,				IDS_TOTMEM},
			  {&pszFreeMem, 			IDS_FREEMEM},
			  {&pszMemTextDisabledProg, IDS_MEMTEXTDISABLEDPROG},
			  {&pszMemTextDisabledCmd,	IDS_MEMTEXTDISABLEDCMD},
			  {&pszMemTextDisabledFail, IDS_MEMTEXTDISABLEDFAIL},
			  {&pszMemTextDisabledRID,	IDS_MEMTEXTDISABLEDRID},
			  {&pszMemTextNotloaded,	IDS_MEMTEXTNOTLOADED},
			  {&pszDebugDOSMem,		IDS_DEBUGDOSMEM},
			  {&pszDebugTotal,			IDS_DEBUGTOTAL},
			  {&pszNoWriteINIFile,		IDS_NOWRITEINIFILE},
			  {&pszINIFileName,		IDS_INIFILENAME},
			  {&pszINISectName,		IDS_INISECTNAME},
			  {&pszINICFGSect,			IDS_INICFGSECT},
			  {&pszINIMAXPath,			IDS_INIMAXPATH},
			  {&pszINIMAXHelp,			IDS_INIMAXHELP},
			  {&pszINILineName,		IDS_INILINENAME},
			  {&pszINIProgSect,		IDS_INIPROGSECT},
			  {&pszINIGenSect,			IDS_INIGENSECT},
			  {&pszINIXPosName,		IDS_INIXPOSNAME},
			  {&pszINIYPosName,		IDS_INIYPOSNAME},
			  {&pszINIOntopName,		IDS_INIONTOPNAME},
			  {&pszINIRegSect,			IDS_INIREGSECT},
			  {&pszINIRegName,			IDS_INIREGNAME},
			  {&pszINIRegCompany,		IDS_INIREGCOMPANY},
			  {&pszINIRegSN,			IDS_INIREGSN},
			  {&pszAppName, 			IDS_APPNAME},
			  {&pszDrvName, 			IDS_DRVNAME},
			  {&pszFileClass,			IDS_FILECLASS},
			  {&pszGADialog,			IDS_GADIALOG},
			  {&pszVersionMismatch, 	IDS_VERSIONMISMATCH},
			  {&pszVersion, 			IDS_VERSION},
		 };


//************************************************************************
//	int PASCAL WinMain
//
//	Description:
//	An extremely simple WinMain
//
//	Returns:
//	Success:  TRUE
//	Failure:  FALSE
//************************************************************************

int PASCAL WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
					LPSTR lpszCmdLine, int nCmdShow)
{
 MSG Msg;			// Windows Message
 HWND hWnd=0;		// Local window handle
 char *pLocMem; 	// Pointer to local memory
 WORD wAlloc, wLen, wHead;
 WNDCLASS wc;
 char szTemp[64];

	// If there's a previous instance, switch to it
	if (hPrevInstance)
	{
	GetInstanceData(hPrevInstance, (BYTE *) &hDlgBox, sizeof(hDlgBox));
	ShowWindow(hDlgBox, SW_RESTORE);	// Restore in case minimized
	SetActiveWindow(hDlgBox);			// Make it the active window
		return FALSE;
	} // End IF

	// Allocate local memory for the strings
	wAlloc = 4*1024;			// Amount to allocate (it's arbitrary)
	pLocMem = (char *) LocalAlloc(LMEM_FIXED, wAlloc);	// Allocate it

	// Load the strings into local memory
	for (wHead = 0; wHead < sizeof(pLS)/sizeof(LPLS); wHead++)
	{
		*pLS[wHead].ppLS = pLocMem;			// Save as next location
		wLen = LoadString(hInstance, pLS[wHead].wRes, pLocMem, wAlloc); // Count in the trailing zero
		if (wLen == 0)							// If it doesn't exist
		{
			wsprintf(szTemp, "String #%d missing.", pLS[wHead].wRes);
			MessageBox(hWnd, szTemp, "Go Ahead", MB_OK);
		} // End IF
		pLocMem += wLen + 1;					// Skip over the string
		wAlloc -= wLen + 1;					// Reduce the amount remaining
	} // End FOR

	// Check the Windows version # as we need to vary our behavior for Win95
	wVer = (WORD) GetVersion();
	wVer = (LOBYTE(wVer) << 8) | HIBYTE(wVer);	// Swap to comparison order

	// If we're on Win95, the caption is displayed in the Task Bar
	// where \r doesn't cut it.  Instead use Win95 formats.
	if (wVer >= 0x035F) // If it's Win95 or later
	{
		pszCaptionMinDis = pszCaptionMinDis95;
		pszCaptionMinEna = pszCaptionMinEna95;
	} // End IF

	// Our help file is assumed to be pointed to by the
	// szINIMAXPath,szINIMAXHelp in the QMAX.INI file
	GetPrivateProfileString(pszINICFGSect, pszINIMAXPath, "",
							szHlpDPFE, sizeof(szHlpDPFE), pszINIFileName);
	wLen = lstrlen (szHlpDPFE);
	if (wLen == 0 || szHlpDPFE[wLen - 1] != '/')    // If there's no trailing backslash
		szHlpDPFE[wLen++] = '\\';               // Append backslash
	GetPrivateProfileString(pszINICFGSect, pszINIMAXHelp, "",
							szHlpDPFE + wLen, sizeof(szHlpDPFE) - wLen,
							pszINIFileName);

	// When we attempt to open the driver, we first use the driver
	// name without any preceding drive & path.  If that fails, we attempt
	// to open the same name driver with a drive & path preceding
	// it which are the same as the drive and path of this app.
	if (GetModuleFileName(hInstance, szAppDPFE, sizeof (szAppDPFE)))
	{
		// Split out the drive and path from the module filename
		_splitpath (szAppDPFE,	szDrive, szDir, NULL,	 NULL);
		// Split out the filename from pszDrvName
		_splitpath (pszDrvName, NULL,	 NULL,	szFname, szExt);
		// Re-assemble the separate components
		_makepath  (szDrvDPFE,	szDrive, szDir, szFname, szExt);
	} // End IF

	// Initialize 3-D support
	// Note that we're using a private dialog class (for the minimized
	//	 icon), so Ctl3dAutoSubclass(hInstance) does nothing for us.
	//	 Instead, we call Ctl3dSubclassEx in WM_INITDIALOG to get
	//	 3D effects for this dialog box.
	Ctl3dRegister(hInstance);

	nMinState = nCmdShow;		// Save for use within the Dialog Box

	// Load the icons
	hIconGo   = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICONGO));
	hIconStop = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICONSTOP));
	hIconCur = hIconGo;		// Save as current icon

	// Register a class for the dialog box so we can specify an icon
	//	 if the dialog box is minimized.
	wc.style = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW;
	wc.lpfnWndProc = DefDlgProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = DLGWINDOWEXTRA;
	wc.hInstance = hInstance;
	wc.hIcon = NULL;
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = COLOR_WINDOW + 1;
	wc.lpszMenuName = NULL;
	wc.lpszClassName = pszFileClass;

	if (!RegisterClass(&wc))
	{
		MessageBox(hWnd, pszNoRegClass, pszAppName, MB_OK);

		// Release any resources allocated
		DestroyIcon(hIconGo);
		DestroyIcon(hIconStop);
		Ctl3dUnregister(hInstance);
	} // End IF

	// Create the dialog box -- note that this dialog's registered class
	//	 is also FILECLASS which is from where its icon (when minimized) comes.
	hDlgBox = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_MAINWINDOW), hWnd, DlgProc);
	if (hDlgBox == NULL)
	{
		MessageBox(hWnd, pszNoCreateDlgMain, pszAppName, MB_OK);

		// Release any resources allocated
		DestroyIcon(hIconGo);
		DestroyIcon(hIconStop);
		Ctl3dUnregister(hInstance);
		UnregisterClass (pszFileClass, hInstance);

		return FALSE;
	} // End IF

	// Main message loop
	while (GetMessage (&Msg, NULL, 0, 0))
	   if (!IsDialogMessage (hDlgBox, &Msg))
	   {
		   TranslateMessage (&Msg);
		   DispatchMessage (&Msg);
	   } // While message available

	// GetMessage returned FALSE for a Quit message

	// Release any resources allocated
	DestroyIcon(hIconGo);
	DestroyIcon(hIconStop);
	Ctl3dUnregister(hInstance);
	UnregisterClass (pszFileClass, hInstance);

	return TRUE;
} // End of WinMain()


//************************************************************************
//	HDRVR LclOpenDriver(void)
//
//	Description:
//	Attempt to open the driver without and with a full path
//
//	Returns:
//	 HDRVR or NULL
//************************************************************************

HDRVR LclOpenDriver (void)
{
	HDRVR hDriver;

	pszOpenName = pszDrvName;		// Save the name for later use
	hDriver = OpenDriver(pszOpenName, NULL, NULL);	// Try without full path

	if (hDriver == NULL)							// If the open failed, ...
	{
		pszOpenName = szDrvDPFE;	// Save the name for later use
		hDriver = OpenDriver(pszOpenName, NULL, NULL); // This time with a full path
	} // End IF

	return hDriver;

} // End LclOpenDriver()


//************************************************************************
//	long LclFileVersion(PSTR pszFileName)
//
//	Get file version information
//************************************************************************

long LclFileVersion(PSTR pszFileName)
{
	DWORD dwVerHandle;	// Version file handle
	DWORD dwVerSize;	// Size of the VERSIONINFO struc
	LPSTR lpVer, lpBuf;
	HLOCAL hLoc;
	UINT  lpcb;
	LONG  ret;

	dwVerSize = GetFileVersionInfoSize(pszFileName, &dwVerHandle);

	if (dwVerSize == 0)	// If it didn't work, ...
		return NULL;

	// Allocate space for the file version info
	hLoc = LocalAlloc(LPTR, (WORD) dwVerSize);
	lpVer = (char *) hLoc;
	if (lpVer == NULL)		// If it didn't work
		return NULL;

	// Read in the file version info
	if (!GetFileVersionInfo(pszFileName, dwVerHandle, dwVerSize, lpVer))
		return NULL;

	if (!VerQueryValue(lpVer, "\\", &lpBuf, &lpcb))
		return NULL;

	ret = ((VS_FIXEDFILEINFO FAR *) lpBuf)->dwFileVersionLS;

	LocalFree(hLoc);			// Free the local memory

	return ret;

} // End LclFileVersion()


//************************************************************************
//	char * LclFileVersionStr(PSTR pszFileName)
//
//	Get file version string
//************************************************************************

void LclFileVersionStr(PSTR pszFileName, PSTR szFileVer)
{
	DWORD dwVerHandle;	// Version file handle
	DWORD dwVerSize;	// Size of the VERSIONINFO struc
	DWORD dwTrans;		// Translation value
	LPSTR lpVer, lpBuf;
	HLOCAL hLoc;
	UINT  lpcb;
	char  szTemp[128];

	szTemp[0] = '\0';   // Ensure properly terminated in case we fail
	dwVerSize = GetFileVersionInfoSize(pszFileName, &dwVerHandle);

	if (dwVerSize == 0)	// If it didn't work, ...
		return;

	// Allocate space for the file version info
	hLoc = LocalAlloc(LPTR, (WORD) dwVerSize);
	lpVer = (char *) hLoc;
	if (lpVer == NULL)		// If it didn't work
		return;

	// Read in the file version info
	if (!GetFileVersionInfo(pszFileName, dwVerHandle, dwVerSize, lpVer))
		goto FREE;

	// Get the translation string
	if (!VerQueryValue(lpVer, "\\VarFileInfo\\Translation", &lpBuf, &lpcb))
		goto FREE;

	// Extract the translation value (with the swapped words)
	dwTrans = *(DWORD FAR *)lpBuf;
	wsprintf (szTemp, "\\StringFileInfo\\%08lX\\FileVersion",
						HIWORD(dwTrans), LOWORD(dwTrans));
	if (!VerQueryValue(lpVer, szTemp, &lpBuf, &lpcb))
		goto FREE;

	// Copy to local storage as we're about to free the memory
	lstrcpy (szFileVer, lpBuf);
FREE:
	LocalFree(hLoc);			// Free the local memory

} // End LclFileVersionStr()


//************************************************************************
//	void SetIcon(hDlg)
//
//	Set into place the proper icon depending upon the enabel state
//************************************************************************

void SetIcon(HWND hDlg)
{
	HDC hDC;

	// Get a DC to draw the new icon
	hDC = GetDC(hDlg);

	// Display the proper stop or go icon
	if (wEnableState != wOldEnableState) // If it's changed
	{
		if (wEnableState || !fLoaded)	// If we're disabled or not loaded
			hIconCur = hIconStop;
		else
			hIconCur = hIconGo;

		if (IsIconic(hDlg))
			DrawIcon(hDC, 0, 0, hIconCur);		// Draw the minimized icon
		else
			DrawIcon(hDC, rcIcon1.left, rcIcon1.top, hIconCur); // Draw the icon in main window

	} // End IF

	// We're finished with this DC
	ReleaseDC(hDlg, hDC);	// Bye

} // End SetIcon()


//************************************************************************
//	void DispCaption(HWND, DWORD, DWORD)
//
//	Display the window caption
//************************************************************************

void DispCaption (HWND hDlg, DWORD dwTotal, DWORD dwTaskCnt, UINT fIconic)
{
	char szTemp[64];

	if (fIconic)					// If we're minimized, ...
	{
		if (wEnableState)			// If we're disabled for any reason, ...
			wsprintf(szTemp, pszCaptionMinDis, dwTaskCnt);
		else
		if (fLoaded)				// If we're loaded
			wsprintf(szTemp, pszCaptionMinEna,
							(dwTotal+512)/1024, // Rounded to nearest KB
							dwTaskCnt);
		else						// We're not loaded
			wsprintf(szTemp, pszCaptionUnl);
		SetWindowText(hDlg, szTemp);
		SetIcon(hDlg);
	} // Middle IF/ELSE
	else
		SetWindowText(hDlg, pszCaptionMax);

} // End DispCaption()


//************************************************************************
//	void GetDlgRect(HWND hDlg, int wCtrl, RECT * lpRect)
//
//	Fill in the rectangle with the coordinates of the control within
//	a window.
//************************************************************************

void GetDlgRect(HWND hDlg, int wCtrl, RECT * lpRect)
{
	WORD wTop, wLeft;

	// Get the size of the control
	GetWindowRect(hDlg, lpRect);

	// Save the coordinates of the top left point.
	// We also add in the size of the caption bar
	// (which includes the border) to the top point
	// and the size of the left border to the left point
	// to get client coordinates when we subtract.
	wTop  = lpRect->top  + GetSystemMetrics(SM_CYCAPTION);
	wLeft = lpRect->left + GetSystemMetrics(SM_CXBORDER);

	// Get the window coordinates of the control
	GetWindowRect(GetDlgItem(hDlg, wCtrl), lpRect);

	// Normalize to client coordinates w.r.t. the dialog box
	// omitting the (thin) frame
	lpRect->top    -= wTop - 1;
	lpRect->bottom -= wTop + 1;
	lpRect->left   -= wLeft - 1;
	lpRect->right  -= wLeft + 1;

} // End GetDlgRect()


//************************************************************************
//	void MoveWindowPos(HWND hWnd, WORD xPosCtr, WORD yPosCtr)
//
//	Move the window to a position based upon the previous center
//************************************************************************

void MoveWindowPos(HWND hWnd, WORD xPosCtr, WORD yPosCtr)
{
	RECT rcWnd;
	WORD wWidth, wHeight;

	GetWindowRect(hWnd, &rcWnd);					// Get the window's RECT
	wWidth	= rcWnd.right  - rcWnd.left;			// Calc the width
	wHeight = rcWnd.bottom - rcWnd.top;			// Calc the height
	MoveWindow(hWnd,
				xPosCtr - wWidth/2,				// Left coordinate
				yPosCtr - wHeight/2,				// Top ...
				wWidth, 							// Width
				wHeight,							// Height
				FALSE); 							// No re-paint
 } // End MoveWindowPos()


//************************************************************************
//	void CenterWindow(HWND hWnd)
//
//	Center the window on the desktop
//************************************************************************

void CenterWindow(HWND hWnd)
{
	RECT rcWnd;
	WORD xPosCtr, yPosCtr;

	GetWindowRect(GetDesktopWindow(), &rcWnd);				// Get the desktop's RECT
	xPosCtr = rcWnd.left + (rcWnd.right  - rcWnd.left)/2;	// Center horizontally
	yPosCtr = rcWnd.top  + (rcWnd.bottom - rcWnd.top )/2;	// Center vertically
	MoveWindowPos(hWnd,
				xPosCtr,									// Center x-coordinate
				yPosCtr);									// ...	  y-...

 } // End CenterWindow()


//************************************************************************
//	void DispMemBar(HWND hDlg)
//
//	Display the low DOS memory bar
//************************************************************************

void DispMemBar(HWND hDlg, HDC hDCBar)
{
	char szTemp[64];
	WORD wRight;
	HBRUSH hBrush;

	// Display the low DOS memory size
	if (fLoaded)
		wsprintf(szTemp, pszTotMem, (dwSizeDOS+512)/1024); // Convert to KB
	else	// Not loaded, no low DOS memory size
		szTemp[0] = '\0';
	SetDlgItemText(hDlg, IDC_MEMCNT, (LPCSTR) szTemp); // Display low DOS memory size

	SetTextColor(hDCBar, GetSysColor(COLOR_BTNTEXT));	// Set text color
	SelectObject(hDCBar, GetStockObject(SYSTEM_FONT));	// Set text font

	// Draw the entire bar
	hBrush = CreateSolidBrush(WHITE);		// Get a White brush
	FillRect(hDCBar, &rcMemBar, hBrush);	// Paint the entire bar
	DeleteObject(hBrush);					// Delete it

	// Calculate the width of the colored bar to draw
	wRight = rcMemBar.right;				// Save to use when writing the text
	if (wEnableState)						// If we're disabled for any reason, ...
		rcMemBar.right = rcMemBar.left;
	else
		rcMemBar.right = rcMemBar.left + (int) ((dwMemBarWidth * dwTotal)/dwSizeDOS);

	// Draw the foreground
	hBrush = CreateSolidBrush(GREEN);		// Get a Green brush
	FillRect(hDCBar, &rcMemBar, hBrush);	// Paint the left side of bar
	DeleteObject(hBrush);					// Delete it

	// Set the text
	SetBkMode(hDCBar, TRANSPARENT); 	// So the text doesn't write on background

	if (!fLoaded)
		lstrcpy(szTemp, pszMemTextNotloaded);
	else	// Middle If/ELSE
	switch (wEnableState)
	{
		case 0: 		// We're enabled
			wsprintf(szTemp, pszFreeMem, (dwTotal+512)/1024);	// Format the text to draw
			EnableWindow(GetDlgItem(hDlg, IDC_ABLE), TRUE); 	// Allow
			break;

		case 1: 		// We're disabled due to command
			lstrcpy(szTemp, pszMemTextDisabledCmd);
			EnableWindow(GetDlgItem(hDlg, IDC_ABLE), TRUE); 	// Allow
			break;

		case 2: 		// We're disabled due to program
			lstrcpy(szTemp, pszMemTextDisabledProg);
			EnableWindow(GetDlgItem(hDlg, IDC_ABLE), FALSE);	// Disallow
			break;

		case 3: 		// We're disabled due to failsafe
			lstrcpy(szTemp, pszMemTextDisabledFail);
			EnableWindow(GetDlgItem(hDlg, IDC_ABLE), FALSE);	// Disallow
			break;

		case 4: 		// We're disabled due to incompatible driver
			lstrcpy(szTemp, pszMemTextDisabledRID);
			EnableWindow(GetDlgItem(hDlg, IDC_ABLE), FALSE);	// Disallow

			if (!fRID)	// If we've not displayed this before, ...
			{
				HINSTANCE hInst;
				BOOL (FAR *lpfnGADialog)(HWND, int);

				fRID = TRUE;	// So we don't call it again
				hInst = LoadLibrary (pszDrvName);
				if ((UINT) hInst >= 32) // If it worked, ...
				{
					(FARPROC) lpfnGADialog = GetProcAddress (hInst, pszGADialog);
					if (lpfnGADialog != NULL)	// If it worked, ...
						lpfnGADialog (hDlg, 0); // call it
					FreeLibrary (hInst); // Decrement reference count
				} // End IF
			} // End IF

			break;
	} // End switch (wEnableState)

	// Draw the text
	rcMemBar.right = wRight;					// Restore the original width
	DrawText(hDCBar, szTemp, lstrlen(szTemp), &rcMemBar,
			DT_CENTER | DT_VCENTER | DT_SINGLELINE);

} // End DispMemBar()


//************************************************************************
//	Local Edit Box procedure to get underneath CTL3D
//
//************************************************************************

long WINAPI LclEB (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	long dwRes;
	HDC hDC;

	dwRes = CallWindowProc(lpfnOldEB, hWnd, message, wParam, lParam); // Pass on down the line

	if ((hWnd == hMemBar)			// If it's our control, ...
	 && (message == WM_PAINT))		// and it's time to paint, ...
	{
		hDC = GetDC(hDlgBox);		// Get a device context
		DispMemBar(hDlgBox, hDC);	// Display the low DOS memory bar
		ReleaseDC(hDlgBox, hDC);	// Bye
	} // End IF

	return dwRes;					// Return the original result

} // End LclEB()


//************************************************************************
//	void SaveProfile(HWND hDlg)
//
//	Save the profile with the current values
//************************************************************************

void SaveProfile(void)
{
	char szTemp[64];			// Room for verious strings

	// Write out the [Go Ahead - General] section .INI file settings
	wsprintf(szTemp, "%d", xPosCtr);
	WritePrivateProfileString(pszINIGenSect, pszINIXPosName,  szTemp, pszINIFileName);
	wsprintf(szTemp, "%d", yPosCtr);
	WritePrivateProfileString(pszINIGenSect, pszINIYPosName,  szTemp, pszINIFileName);
	wsprintf(szTemp, "%d", fOntop);
	WritePrivateProfileString(pszINIGenSect, pszINIOntopName, szTemp, pszINIFileName);

} // SaveProfile()


//************************************************************************
//	void DriverUnl (HWND)
//
//	Set buttons for driver not loaded
//************************************************************************

void DriverUnl (HWND hDlg)
{
	// Driver not installed -- set default button status
	EnableWindow (GetDlgItem(hDlg, IDC_ABLE),  FALSE);		// Disallow
	EnableWindow (GetDlgItem(hDlg, IDC_PROGRAMS), FALSE);	// Disallow
	SetWindowText(hDlg, pszCaptionMax); // Set caption when maximized
	SetDlgItemText(hDlg, IDC_STATUS, (LPCSTR) pszStatusUnl); // Display status
	fLoaded = FALSE;		// Mark as not loaded
	SetIcon(hDlg);			// Set into place the proper icon

} // End DriverUnl ()


//************************************************************************
//	BOOL CALLBACK _export DlgProc
//
//	Description:
//	The dialog controls result in the various
//	WM_COMMAND messages which this function handles.  Everything else
//	is uninteresting, so we let the dialog manager handle it.
//
//	Returns:
//	 TRUE or FALSE to indicate to dialog manager whether we handled msg
//************************************************************************

BOOL CALLBACK _export DlgProc (HWND hDlg, UINT message, WPARAM wParam,
							LPARAM lParam)
{
	LRESULT lResult;			// Result from driver
	HDRVR hDriver;				// Handle of driver
	char szTemp[64];			// Room for verious strings
	static HWND hSysMenu;		// Handle of system menu
	DWORD dwVerDrv, dwVerApp;	// Driver and application version #s
	RECT rcDtop;				// Rectangle for desktop
	WORD xPos, yPos;			// x- and y- positions
	PAINTSTRUCT ps; 			// For painting

	switch (message)
	{
		case WM_INITDIALOG:
			hDlgBox = hDlg; 	// Save for later use

			// Because we're using a private dialog class, we need these
			Ctl3dSubclassDlgEx(hDlg, CTL3D_ALL);
			Ctl3dAutoSubclass(_hInstance);

			// Save the window size for use in WM_MOVE messages
			GetWindowRect(hDlg, &rcDtop);
			xSize = rcDtop.right  - rcDtop.left;
			ySize = rcDtop.bottom - rcDtop.top;

			// Setup the default values in case the .INI file is not present
			GetWindowRect(GetDesktopWindow(), &rcDtop);
			xPos = xPosCtr = rcDtop.left + (rcDtop.right  - rcDtop.left)/2; // Center horizontally
			yPos = yPosCtr = rcDtop.top  + (rcDtop.bottom - rcDtop.top )/2; // Center vertically

			// Read in the [Go Ahead - General] section settings from the .INI file
			xPosCtr = GetPrivateProfileInt(pszINIGenSect, pszINIXPosName, xPosCtr, pszINIFileName);
			yPosCtr = GetPrivateProfileInt(pszINIGenSect, pszINIYPosName, yPosCtr, pszINIFileName);

			if (wVer < 0x035F)		// On top needed for pre-Win95 only
				fOntop = GetPrivateProfileInt(pszINIGenSect, pszINIOntopName, fOntop, pszINIFileName);

			if (xPosCtr > (WORD) rcDtop.right)	// If center is right of right, ...
				xPosCtr = xPos;
			if (yPosCtr > (WORD) rcDtop.bottom) // If center is below the bottom, ...
				yPosCtr = yPos;

			MoveWindowPos(hDlg, xPosCtr, yPosCtr); // Reposition the window to previous center

			// Insert our About box and Always On Top selections into the system menu
			hSysMenu = GetSystemMenu(hDlg, FALSE);
			AppendMenu(hSysMenu, MF_SEPARATOR, 0, (LPSTR) NULL);
			if (wVer < 0x035F)		// On top needed for pre-Win95 only
			{
				AppendMenu(hSysMenu, MF_STRING, IDM_ONTOP, pszMenuOntop);
				AppendMenu(hSysMenu, MF_SEPARATOR, 0, (LPSTR) NULL);
			} // End IF
			AppendMenu(hSysMenu, MF_STRING, IDM_OVERVIEW, pszMenuOverview);
			AppendMenu(hSysMenu, MF_STRING, IDM_SEARCH,   pszMenuSearch);
			AppendMenu(hSysMenu, MF_SEPARATOR, 0, (LPSTR) NULL);
			AppendMenu(hSysMenu, MF_STRING, IDM_TECHSUPP, pszMenuTechSupp);
			AppendMenu(hSysMenu, MF_SEPARATOR, 0, (LPSTR) NULL);
			AppendMenu(hSysMenu, MF_STRING, IDM_ABOUT, pszMenuAbout);

			// Set default menu state
			if (fOntop)
				CheckMenuItem(hSysMenu, IDM_ONTOP, MF_CHECKED);
			else
				CheckMenuItem(hSysMenu, IDM_ONTOP, MF_UNCHECKED);

			// Fill in the client coordinates of the low DOS memory bar
			GetDlgRect(hDlg, IDC_MEMBAR, &rcMemBar);
			dwMemBarWidth = (DWORD) (rcMemBar.right - rcMemBar.left); // Overall bar width

			// Fill in the client coordinates of the main window icon
			GetDlgRect(hDlg, IDC_ICON1, &rcIcon1);

			// The scheme we use to determine whether or not the dirver was loaded at
			// [boot] section time is to count DRV_CLOSE messages.	If the driver was
			// loaded at [boot] time, it has a persistent data segment and the count of
			// DRV_CLOSE messages can be non-zero.	If the driver wasn't loaded at [boot]
			// time, then each time we open the driver the data segment is established
			// anew and the count of DRV_CLOSE messages must always be zero.
			hDriver = LclOpenDriver();				// Open it just so we can close it
			if (hDriver != NULL)
				CloseDriver(hDriver, NULL, NULL);	// Ensure at least one close

			hDriver = LclOpenDriver();
			if (hDriver == NULL)
			{
				// Driver not present
				MessageBox(hDlg, pszNoFindDrvr, pszAppName, MB_ICONSTOP);
				DriverUnl (hDlg);		// Set buttons for not loaded
			}
			else
			{
				// Read in the driver's Least Significant version info
				dwVerDrv = LclFileVersion(pszOpenName);

				// Read in the application's Least Significant version info
				dwVerApp = LclFileVersion(szAppDPFE);

				// Check for validity and equality
				if (dwVerDrv == NULL || dwVerApp == NULL || dwVerDrv != dwVerApp)
				{
					MessageBox(hDlg, pszVersionMismatch, pszAppName, MB_ICONSTOP);
					PostMessage(hDlg, WM_CLOSE, NULL, NULL);
					return FALSE;
				} // End IF

				// See how many times this driver has been closed.	If it's > 0, then
				// it must have a persistent data segment, and thus it's been loaded
				// via "drivers=" line in [boot] section in SYSTEM.INI, hence installed.
				lResult = SendDriverMessage(hDriver, LCLDRV_QUERYCLOSE, NULL, NULL);
				if (lResult)	// If it's already installed, ...
				{
					// Register our WinApp with the driver so we are informed of DOS memory changes
					lResult = SendDriverMessage(hDriver, LCLDRV_REGISTER, (LPARAM) hDlg,
											MAKELONG(IDC_MEMCHANGED, IDC_TASKCHANGED));
					EnableWindow(GetDlgItem(hDlg, IDC_PROGRAMS), TRUE);	// Allow

					// To find the current enable/disable state, we query the driver
					// The result is 0 if enabled, 1 if disabled by command,
					//		 2 if disabled by program, 3 if disabled by failsafe
					//		 4 if disabled by incompatible driver
					wOldEnableState = wEnableState; // Save the old state
					wEnableState = (WORD) SendDriverMessage(hDriver, LCLDRV_QUERYENABLE, NULL, NULL);

					// Set the open/icon state to the initial value
					// unless we're disabled due to an incompatible driver
					// in which case we do not minimize
					ShowWindow(hDlg, (wEnableState != 4) ? nMinState : SW_RESTORE); // Do so

					SetIcon(hDlg);			// Set into place the proper icon
					if (wEnableState == 0)	// If it's enabled
					{
						EnableWindow (GetDlgItem(hDlg, IDC_ABLE), TRUE);		// Allow
						SetWindowText(GetDlgItem(hDlg, IDC_ABLE), pszButtonDisable);	// Set next state
						SetDlgItemText(hDlg, IDC_STATUS, (LPCSTR) pszStatusEna); // Display status
					}
					else					// It's disabled
					{
						EnableWindow (GetDlgItem(hDlg, IDC_ABLE), TRUE);		// Allow
						SetWindowText(GetDlgItem(hDlg, IDC_ABLE), pszButtonEnable); // Set next state
						SetDlgItemText(hDlg, IDC_STATUS, (LPCSTR) pszStatusDis); // Display status
					} // End IF/ELSE

					fLoaded = TRUE;
				} // Middle IF/ELSE
				else
					DriverUnl (hDlg);	// Set buttons for not loaded

				if (CloseDriver(hDriver, NULL, NULL) == 0)
					MessageBox(hDlg, pszNoCloseDrvr, pszAppName, MB_OK);

				// Because CTL3D wants to erase the low DOS memory bar we so carefully
				// have drawn, we'll subclass the edit box control and redraw the bar after
				// the WM_PAINT message
				hMemBar = GetDlgItem(hDlg, IDC_MEMBAR); 	// Get the window handle
				lpfnOldEB = (FARPROC) GetWindowLong(hMemBar, GWL_WNDPROC); // Save the old proc
				SetWindowLong(hMemBar, GWL_WNDPROC, (LONG) (FARPROC) LclEB); // Install our own
				SetFocus(GetDlgItem(hDlg, IDOK));
			} // End IF/ELSE

			return FALSE;		// We called SetFocus ourselves

	case WM_MOVE:
		if (!IsIconic(hDlg))		// If we're not minimized, otherwise
		{							// the positions are of the icon
			GetWindowRect(hDlg, &rcDtop);	// Get current window positions
			xPosCtr = rcDtop.left + xSize/2; // Convert to center coords
			yPosCtr = rcDtop.top  + ySize/2; // ...
		} // End IF

		return FALSE;

	case WM_CLOSE:
		hDriver = LclOpenDriver();
		if (hDriver != NULL)
		{
		SendDriverMessage(hDriver, LCLDRV_UNREGISTER, (LPARAM) hDlg, NULL);
		if (CloseDriver(hDriver, NULL, NULL) == 0)
			MessageBox(hDlg, pszNoCloseDrvr, pszAppName, MB_OK);
		} // End IF

		if (fHelp && szHlpDPFE[0])	 // If we used help and there's a valid .HLP file, ...
		WinHelp (hDlg, szHlpDPFE, HELP_QUIT, NULL); // Quit it

		SaveProfile();
		DestroyWindow(hDlg);
		return TRUE;			// Indicate we handled this message

	case WM_QUERYENDSESSION:
		SaveProfile();
		return FALSE;			// Indicate we're happy to close

	case WM_DESTROY:
		PostQuitMessage(0);
		return FALSE;

	case WM_QUERYDRAGICON:
		return hIconCur;

	case WM_PAINT:
	case WM_PAINTICON:
		BeginPaint(hDlg, &ps);

		if (IsIconic(hDlg))
		{
			SendMessage(hDlg, WM_ICONERASEBKGND, ps.hdc, NULL);
			DrawIcon(ps.hdc, NULL, NULL, hIconCur);
			UpdateWindow(hDlg);
		} // Middle IF/ELSE
		else
			DrawIcon(ps.hdc, rcIcon1.left, rcIcon1.top, hIconCur); //Draw icon in main window

		EndPaint(hDlg, &ps);

		return TRUE;			// Indicate we handled the message

	case WM_SYSCOMMAND:
		switch (wParam & 0xFFF0)
		{
			case IDM_ABOUT:
				if (GetAsyncKeyState(VK_CONTROL) & 0x8000) // If either control key is pressed, ...
					DialogBox(_hInstance, MAKEINTRESOURCE(IDD_DEBUG), hDlg, Debug);
				else
					DialogBox(_hInstance, MAKEINTRESOURCE(IDD_ABOUT), hDlg, About);
				break;

				return TRUE;		// Indicate we handled the message

			case IDM_OVERVIEW:
				if (szHlpDPFE[0])	// If there's a valid .HLP file, ...
				{
					WinHelp(hDlg, szHlpDPFE, HELP_KEY, (DWORD) (LPSTR) pszHelpKeyOverview); // Display it
					fHelp = TRUE;
				} // End IF
				break;

			case IDM_SEARCH:
				if (szHlpDPFE[0])	// If there's a valid .HLP file, ...
				{
					WinHelp(hDlg, szHlpDPFE, HELP_PARTIALKEY, (DWORD) (LPSTR) ""); // Display it
					fHelp = TRUE;
				} // End IF
				break;

			case IDM_TECHSUPP:
				if (szHlpDPFE[0])	// If there's a valid .HLP file, ...
				{
					WinHelp(hDlg, szHlpDPFE, HELP_KEY, (DWORD) (LPSTR) pszHelpKeyTechSupp); // Display it
					fHelp = TRUE;
				} // End IF
				break;

			case IDM_ONTOP:
				fOntop = !fOntop;	// Toggle the state
				if (fOntop)
					CheckMenuItem(hSysMenu, IDM_ONTOP, MF_CHECKED);
				else
					CheckMenuItem(hSysMenu, IDM_ONTOP, MF_UNCHECKED);
				// If we're minimized, change the state
				if (IsIconic(hDlg))
				if (fOntop)
					SetWindowPos(hDlg, HWND_TOPMOST,   NULL, NULL, NULL, NULL, SWP_NOMOVE | SWP_NOSIZE);
				else
					SetWindowPos(hDlg, HWND_NOTOPMOST, NULL, NULL, NULL, NULL, SWP_NOMOVE | SWP_NOSIZE);
				return TRUE;		// Indicate we handled the message

			case SC_MINIMIZE:
				DispCaption(hDlg, dwTotal, dwTaskCnt, TRUE);	// Display the window caption
				if (fOntop)
					SetWindowPos(hDlg, HWND_TOPMOST,   NULL, NULL, NULL, NULL, SWP_NOMOVE | SWP_NOSIZE);
				return FALSE;		// Tell W to continue processing

			case SC_RESTORE:
				DispCaption(hDlg, dwTotal, dwTaskCnt, FALSE);	// Display the window caption
				if (fOntop)
					SetWindowPos(hDlg, HWND_NOTOPMOST, NULL, NULL, NULL, NULL, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
				return FALSE;		// Tell W to continue processing

		}	// End switch (wParam)
		return FALSE;				// Indicate we didn't handle the message

	case WM_USER:
		switch (wParam)
		{
			case IDC_MEMCHANGED:
				// The DOS memory status has changed
				// lParam = dwTotal (free DOS in bytes)
				hDriver = LclOpenDriver();		// Attempt to open the driver, ...
				if (hDriver == NULL)
					MessageBox(hDlg, pszNoOpenDrvr, pszAppName, MB_OK);
				else
				{
					// Get lowest free segment ever encountered
					dwSizeDOS = 640L*1024L - 16L*SendDriverMessage(hDriver, LCLDRV_QUERYLOWSEG, NULL, NULL);

					wOldEnableState = wEnableState; // Save the old state
					wEnableState = (WORD) SendDriverMessage(hDriver, LCLDRV_QUERYENABLE, NULL, NULL);
					SetIcon(hDlg);			// Set into place the proper icon
					if (wEnableState == 0)
						dwTotal = lParam; // It's enabled
					else
						dwTotal = (DWORD) -1; // It's disabled

					DispCaption(hDlg, dwTotal, dwTaskCnt, IsIconic(hDlg));	// Display the window caption

					if (!IsIconic(hDlg))	// If we're not minimized, ...
						InvalidateRect(hDlg, &rcMemBar, FALSE);

					if (CloseDriver(hDriver, NULL, NULL) == 0)
					{
						MessageBox(hDlg, pszNoCloseDrvr, pszAppName, MB_OK);
						break;
					} // End IF
				} // End IF/ELSE
				break;

			case IDC_TASKCHANGED:
				// The task count has changed
				// lParam = new task count
				dwTaskCnt = lParam;

				DispCaption(hDlg, dwTotal, dwTaskCnt, IsIconic(hDlg));	// Display the window caption

				wsprintf(szTemp, pszTaskCnt, dwTaskCnt);
				SetDlgItemText(hDlg, IDC_TASKCNT, (LPCSTR) szTemp); // Display the task count

				break;

			default:
				return TRUE;		// Indicate we did not process this msg
		} // End switch (wParam)

		return FALSE;		// Indicate we processed this msg

	case WM_COMMAND:
		switch (wParam)
		{
			case IDC_ABLE:
				if (wEnableState >= 2)	// If it's disabled by program or failsafe, ...
					break;				// There's nothing much to do

				hDriver = LclOpenDriver();		// Attempt to open the driver, ...
				if (hDriver == NULL)
					MessageBox(hDlg, pszNoOpenDrvr, pszAppName, MB_OK);
				else
				{
					// To find the current enable/disable state, we query the driver
					wOldEnableState = wEnableState; // Save the old state
					wEnableState = (WORD) SendDriverMessage(hDriver, LCLDRV_QUERYENABLE, NULL, NULL);
					SetIcon(hDlg);			// Set into place the proper icon
					if (wEnableState == 0)	// If it's enabled, ...
					{
						if (TRUE == SendDriverMessage(hDriver, LCLDRV_DISABLE, NULL, NULL))
						{
							EnableWindow (GetDlgItem(hDlg, IDC_ABLE), TRUE);		// Allow
							SetWindowText(GetDlgItem(hDlg, IDC_ABLE), pszButtonEnable); // Set next state
							SetDlgItemText(hDlg, IDC_STATUS, (LPCSTR) pszStatusDis); // Display status
						} // End IF
					} // Middle IF/ELSE
					else					// It's disabled
					{
						if (TRUE == SendDriverMessage(hDriver, LCLDRV_ENABLE, NULL, NULL))
						{
							EnableWindow (GetDlgItem(hDlg, IDC_ABLE), TRUE);		// Allow
							SetWindowText(GetDlgItem(hDlg, IDC_ABLE), pszButtonDisable);	// Set next state
							SetDlgItemText(hDlg, IDC_STATUS, (LPCSTR) pszStatusEna); // Display status
						} // End IF
					} // End IF/ELSE

					if (CloseDriver(hDriver, NULL, NULL) == 0)
					{
						MessageBox(hDlg, pszNoCloseDrvr, pszAppName, MB_OK);
						break;
					} // End IF
				} // End IF/ELSE

				break;

			case IDOK:
				PostMessage(hDlg, WM_SYSCOMMAND, SC_MINIMIZE, NULL); // Minimize it
				break;

			case IDC_PROGRAMS:
				if (-1 == DialogBox(_hInstance, MAKEINTRESOURCE(IDD_PROGRAMS), hDlg, Programs))
					// If it didn't work, ...
					MessageBox(hDlg, pszNoCreateDlgProg, pszAppName, MB_OK);
				break;

			case IDC_HELP:
				if (szHlpDPFE[0])	// If there's a valid .HLP file, ...
				{
					WinHelp(hDlg, szHlpDPFE, HELP_KEY, (DWORD) (LPSTR) pszHelpKeyMain); // Display it
					fHelp = TRUE;
				} // End IF

				break;

			default:
				return FALSE;		// We didn't handle the message
		} // End switch (wParam)

		return TRUE;  // We handled the message
	} // End switch (message)

	return FALSE;  // We didn't handle the message

} // End of DlgProc()


//************************************************************************
//	BOOL CALLBACK _export About
//
//	Description:
//	Just yer standard About box.  Boring.
//************************************************************************

BOOL CALLBACK _export About(HWND hDlg,
				UINT message,
				WPARAM wParam,
				LPARAM lParam)
{
	char szTemp[512], szFileVer[32];
	WORD wLen;

	switch (message)
	{
	case WM_INITDIALOG:
			// Read in the application's File Version String
			LclFileVersionStr(szAppDPFE, szFileVer);

			// Format the version #
			wsprintf(szTemp, pszVersion, szFileVer);

			// Write out the version string
			SetDlgItemText(hDlg, IDC_VERSION, szTemp);

			// Get the registration name
			GetPrivateProfileString(pszINIRegSect, pszINIRegName, "",
							szTemp, sizeof(szTemp), pszINIFileName);
			lstrcat(szTemp, "\n");  // Append a line separator
			wLen = lstrlen(szTemp); // Get the length to skip over
			// Get the registration company name
			GetPrivateProfileString(pszINIRegSect, pszINIRegCompany, "",
							szTemp + wLen, sizeof (szTemp) - wLen,
							pszINIFileName);
			lstrcat(szTemp, pszLeadSN); // Append a line separator
									// and leading S/N text
			wLen = lstrlen(szTemp); // Get the length to skip over
			// Get the registration serial #
			GetPrivateProfileString(pszINIRegSect, pszINIRegSN, "",
							szTemp + wLen, sizeof (szTemp) - wLen,
							pszINIFileName);

			// Write out the registration string
			SetDlgItemText(hDlg, IDC_REGISTRATION, szTemp);

		CenterWindow(hDlg);	// Reposition the window to the center of the screen
		return TRUE;			// Use the focus in wParam

		case WM_COMMAND:
			// If the user pressed one of our buttons, ...
			switch (wParam)
			{
				case IDOK:
					EndDialog(hDlg, TRUE);	// Quit this dialog
					return TRUE;	// Indicate we processed this message
			} // End switch (wParam)

			break;
	} // End switch (message)

	return FALSE;					// Indicate we didn't process this message
} // End of About()


//************************************************************************
//	BOOL CALLBACK _export Debug
//
//	Description:
//	Display debug information.
//************************************************************************

#pragma optimize ("", off)
BOOL CALLBACK _export Debug(HWND hDlg,
				UINT message,
				WPARAM wParam,
				LPARAM lParam)
{
	HDRVR hDriver;
	LPDOSMEM lpDOSMem;
	WORD wCnt, wCS, wDS, wWGH;
	typedef long (FAR *LPFN)(void);
	LPFN lpfnGlobalMasterHandle;
	DWORD dwTotal;
	char szTemp[64];	// Room for "xxxx -- xxxx" and "Total bytes:  nnn,nnn"

	switch (message)
	{
		case WM_INITDIALOG:
			hDriver = LclOpenDriver();		// Attempt to open the driver, ...
			if (hDriver == NULL)
				MessageBox(hDlg, pszNoOpenDrvr, pszAppName, MB_OK);
			else
			{
				lpDOSMem = (LPDOSMEM) SendDriverMessage(hDriver, LCLDRV_GETBUFADDR, NULL, NULL);

				wCnt = ((LPWORD) lpDOSMem)[-1]; // Get the count word preceding the table

				// Get the driver's CS and DS
				dwTotal = SendDriverMessage(hDriver, LCLDRV_GETCSDS, NULL, NULL);
		wCS = HIWORD(dwTotal);
		wDS = LOWORD(dwTotal);

#define GETPROC(modname, funcname) GetProcAddress(GetModuleHandle(modname), (funcname))

		// Get the Global heap selector
				lpfnGlobalMasterHandle = (LPFN) GETPROC("KERNEL", "GLOBALMASTERHANDLE");
				wWGH = HIWORD((lpfnGlobalMasterHandle)());

				wsprintf(szTemp, "CS=%04X, DS=%04X, Cnt=%d, WGH=%04X   .", wCS, wDS, wCnt, wWGH);
				SetDlgItemText(hDlg, IDC_REGS, (LPCSTR) szTemp);

				dwTotal = 0;		// Initialize the accumulator
				while (wCnt--)
				{
					wsprintf (szTemp, pszDebugDOSMem,
									lpDOSMem->Seg,
									lpDOSMem->Sel,
									lpDOSMem->ELen,
									lpDOSMem->TLen,
									lpDOSMem->Adj);
					(void) SendDlgItemMessage(hDlg, IDC_SEGLEN, LB_ADDSTRING,
											  0, (LPARAM) (LPCSTR) szTemp);
					dwTotal += lpDOSMem++->ELen;	// Accumulate the total, skip to next entry
				} // End while (wCnt--)

				dwTotal *= 16L; 	// Convert from paras to bytes
				wsprintf (szTemp, pszDebugTotal, dwTotal);
				/// if (dwTotal > 999)	// Handle comma insertion
				/// {					// Copy the last three digits up one in the string
				/// wCnt = lstrlen (szTemp);
				/// szTemp[wCnt+1] = '\0';                  // New string terminator
				/// szTemp[wCnt  ] = szTemp[wCnt-1];
				/// szTemp[wCnt-1] = szTemp[wCnt-2];
				/// szTemp[wCnt-2] = szTemp[wCnt-3];
				/// szTemp[wCnt-3] = ',';                   // Insert the comma
				/// } // End IF

				(void) SetDlgItemText(hDlg, IDC_TOTAL, (LPCSTR) szTemp);

				if (CloseDriver(hDriver, NULL, NULL) == 0)
				{
					MessageBox(hDlg, pszNoCloseDrvr, pszAppName, MB_OK);
					break;
				} // End IF

				return TRUE;					// Use the focus in wParam
			} // End IF/ELSE

			break;

		case WM_COMMAND:
			switch(wParam)
			{
				case IDOK:
					EndDialog(hDlg, TRUE);		// Quit this dialog
					break;
		} // End switch (wParam)
		break;
	} // End switch (message)

	return FALSE;
} // End of Debug()
#pragma optimize ("", on)


//************************************************************************
//	BOOL CALLBACK _export Programs
//
//	Description:
//	Alow the user to specify the names of bozo modules.
//************************************************************************

BOOL CALLBACK _export Programs(HWND hDlg,
				UINT message,
				WPARAM wParam,
				LPARAM lParam)
{
	typedef struct			// Module history
	{
	char ModName[8];	// Module name
	} FAR * LPMODHIST;

	typedef struct			// Profile entries
	{
		char ModName[8];	// Module name
		WORD Para,			// Size (0=not in use)
			 Next,			// Next entry (-1=none)
			 Prev;			// Previous entry (-1=none)
	} FAR * LPMODFILE;

	HDRVR hDriver;
	LPMODHIST lpModHist;
	LPMODFILE lpModFile;
	WORD wHead, wCnt;
	char szTemp[256];		// Room for module name and [programs] entries
	static char szBlank[1+sizeof(lpModHist->ModName)] = "        "; // Test string for all blank
	static WORD wEnd, wStart, wChanged = FALSE, wModcur, wModfile;

	switch (message)
	{
		case WM_INITDIALOG:
			hDriver = LclOpenDriver();		// Attempt to open the driver, ...
			if (hDriver == NULL)
				MessageBox(hDlg, pszNoOpenDrvr, pszAppName, MB_OK);
			else
			{
				CenterWindow(hDlg); // Reposition the window to the center of the screen

				lpModHist = (LPMODHIST) SendDriverMessage(hDriver, LCLDRV_GETMODHISTORY, NULL, NULL);
				lpModFile = (LPMODFILE) SendDriverMessage(hDriver, LCLDRV_GETMODFILE, NULL, NULL);
				if (CloseDriver(hDriver, NULL, NULL) == 0)
				{
					MessageBox(hDlg, pszNoCloseDrvr, pszAppName, MB_OK);
					break;
				} // End IF

				// Get the starting offset for the current module names
				wEnd  = ((LPWORD) lpModHist)[-2];	// Get the ending index preceding the table
				wStart= ((LPWORD) lpModHist)[-3];	// ...	   starting ...
				wHead = ((LPWORD) lpModHist)[-1];	// Get the head offset
		wCnt = wEnd;		// The count is the table size
				while (wCnt--)		// Loop through the table adding items to the module name list box
				{
					// Note that we pre-decrement wHead so as to start
					// with the least recent entry
					if (wHead == wStart)
						wHead = wEnd;

					// Copy the name of the next module
					lstrcpyn(szTemp, lpModHist[--wHead].ModName, 1+sizeof(lpModHist->ModName));
					szTemp[sizeof(lpModHist->ModName)] = '\0';      // Ensure properly terminated if full name

					if (lstrcmp(szTemp, szBlank))	// If it's active
						SendDlgItemMessage(hDlg, IDC_MODCUR, LB_ADDSTRING, 0, (LPARAM) (LPCSTR) szTemp);
				} // End while

				// Get the starting offset for the profile module names
				wCnt = ((LPWORD) lpModFile)[-1];	// Get the # entries
		for (wHead = 0; wHead < wCnt; wHead++) // Loop through the table adding items to the module name list box
		if (lpModFile[wHead].Para)	// If it's active, ...
				{
					// Copy the name of the next module
					lstrcpyn(szTemp, lpModFile[wHead].ModName, 1+sizeof(lpModFile->ModName));
					szTemp[sizeof(lpModFile->ModName)] = '\0';      // Ensure properly terminated if full name

					SendDlgItemMessage(hDlg, IDC_MODFILE, LB_ADDSTRING, NULL, (LPARAM) (LPCSTR) szTemp);
				} // End IF

				EnableWindow(GetDlgItem(hDlg, IDC_SAVE), wChanged); // Changes with wChanged
				SetFocus(GetDlgItem(hDlg, IDC_MODCUR)); // Start in this box
				wModcur = wModfile = 0; 	// Initialize selection indices
				SendDlgItemMessage(hDlg, IDC_MODCUR, LB_SETCURSEL, wModcur, NULL); // Select 1st item
				return FALSE;				// Indicate we called SetFocus ourselves
			} // End IF/ELSE

			break;

		case WM_COMMAND:
			switch(wParam)
			{
				case IDC_MODCUR:
					switch (HIWORD(lParam))
					{
						case LBN_SETFOCUS:	// Activating -- set default button status
							EnableWindow(GetDlgItem(hDlg, IDC_ADD), 	TRUE);	// Allow
							EnableWindow(GetDlgItem(hDlg, IDC_REMOVE),	FALSE); // Disallow

							// Select the current item in this box
							SendDlgItemMessage(hDlg, IDC_MODCUR, LB_SETCURSEL, wModcur, NULL);

							// Deselect the other box
							SendDlgItemMessage(hDlg, IDC_MODFILE, LB_SETCURSEL, (WPARAM) -1, NULL);
							break;

						case LBN_DBLCLK:
							PostMessage(hDlg, WM_COMMAND, IDC_ADD, NULL);
							break;

						case LBN_KILLFOCUS:
							// Save index of current selection
							wModcur = (WORD) SendDlgItemMessage(hDlg, IDC_MODCUR,
																LB_GETCURSEL, NULL, NULL);
							break;
					} // End switch (HIWORD(lparam))

					break;

				case IDC_MODFILE:
					switch (HIWORD(lParam))
					{
						case LBN_SETFOCUS:	// Activating -- set default button status
							EnableWindow(GetDlgItem(hDlg, IDC_REMOVE),	TRUE);	// Allow
							EnableWindow(GetDlgItem(hDlg, IDC_ADD), 	FALSE); // Disallow

							// Select the current item in this box
							SendDlgItemMessage(hDlg, IDC_MODFILE, LB_SETCURSEL, wModfile, NULL);

							// Deselect the other box
							SendDlgItemMessage(hDlg, IDC_MODCUR, LB_SETCURSEL, (WPARAM) -1, NULL);
							break;

						case LBN_DBLCLK:
							PostMessage(hDlg, WM_COMMAND, IDC_REMOVE, NULL);
							break;

						case LBN_KILLFOCUS:
							// Save index of current selection
							wModfile = (WORD) SendDlgItemMessage(hDlg, IDC_MODFILE,
																 LB_GETCURSEL, NULL, NULL);
							break;
					} // End switch (HIWORD(lparam))

					break;

				case IDC_ADD:
					// Get the index of the current selection
					wCnt = (WPARAM) SendDlgItemMessage(hDlg, IDC_MODCUR, LB_GETCURSEL, NULL, NULL);
					if (wCnt != LB_ERR) // Check for error condition
					{
						// Get the text of the current selection
						SendDlgItemMessage(hDlg, IDC_MODCUR, LB_GETTEXT, wCnt, (LPARAM) (LPCSTR) szTemp);

						// If the string is already present, skip it
						if (LB_ERR == SendDlgItemMessage(hDlg,
														 IDC_MODFILE,
														 LB_FINDSTRINGEXACT,
														 (WPARAM) -1,
														 (LPARAM) (LPCSTR) szTemp)) // And not duplicated
						{
							// Send the text to the MODFILE list box
							SendDlgItemMessage(hDlg, IDC_MODFILE, LB_ADDSTRING, NULL, (LPARAM) (LPCSTR) szTemp);

							wChanged = TRUE;			// Mark as having changed MODFILE
							EnableWindow(GetDlgItem(hDlg, IDC_SAVE), wChanged); // Changes with wChanged
						} // End IF
					} // End IF

					break;

				case IDC_REMOVE:
					// Get the index of the current selection
					wCnt = (WPARAM) SendDlgItemMessage(hDlg, IDC_MODFILE, LB_GETCURSEL, NULL, NULL);
					if (wCnt != LB_ERR) // Check for error condition
					{
					// Delete the text
					SendDlgItemMessage(hDlg, IDC_MODFILE, LB_DELETESTRING, wCnt, NULL);

						wChanged = TRUE;			// Mark as having changed MODFILE
						EnableWindow(GetDlgItem(hDlg, IDC_SAVE), wChanged); // Changes with wChanged
					} // End IF

					break;

				case IDC_SAVE:
					// Ask how many items are in the list box
					wCnt = (WORD) SendDlgItemMessage(hDlg, IDC_MODFILE, LB_GETCOUNT, NULL, NULL);

					// Delete the [Go Ahead - Programs] section from the .INI file
					WritePrivateProfileString(pszINIProgSect, NULL, NULL, pszINIFileName);

					// Read back the items from the MODFILE list box and write them to the .INI file
					for (wHead = 0; wHead < wCnt; wHead++)
					{
						SendDlgItemMessage(hDlg, IDC_MODFILE, LB_GETTEXT, wHead, (LPARAM) (LPCSTR) szTemp);
						if (!WritePrivateProfileString(pszINIProgSect, szTemp, "", pszINIFileName))
						{
							MessageBox(hDlg, pszNoWriteINIFile, pszAppName, MB_OK);
							break;
						} // End IF
					} // End FOR

					// Tell the driver to re-read the profile
					hDriver = LclOpenDriver();		// Attempt to open the driver, ...
					if (hDriver == NULL)
					MessageBox(hDlg, pszNoOpenDrvr, pszAppName, MB_OK);
					else
					{
						SendDriverMessage(hDriver, LCLDRV_READPROFILE, NULL, NULL);
						if (CloseDriver(hDriver, NULL, NULL) == 0)
							MessageBox(hDlg, pszNoCloseDrvr, pszAppName, MB_OK);
						else // Middle IF/ELSE
						{
							wChanged = FALSE;		// Finally, it's saved
							EnableWindow(GetDlgItem(hDlg, IDC_SAVE), wChanged); // Changes with wChanged
						} // End IF/ELSE
					} // End IF/ELSE

					break;

				case IDC_HELP:
					if (szHlpDPFE[0])			// If there's a valid .HLP file, ...
					{
					WinHelp(hDlg, szHlpDPFE, HELP_KEY, (DWORD) (LPSTR) pszHelpKeyProg); // Display it
					fHelp = TRUE;
					}
					return TRUE;				// Indicate we handled this message

				case IDC_EXIT:
					if (wChanged)				// Did the user forget to save?
					switch (DialogBox(_hInstance, MAKEINTRESOURCE(IDD_SAVEFILE),
											hDlg, SaveFile)) // If we should save the file, ...
					{
						case IDOK:
							SendMessage(hDlg, WM_COMMAND, IDC_SAVE, NULL);
							break;				// Continue with exit command

						case IDIGNORE:
							break;				// Continue with exit command

						case IDCANCEL:
							return TRUE;		// Indicate we handled this message
					}
					wChanged = FALSE;
					EnableWindow(GetDlgItem(hDlg, IDC_SAVE), wChanged); // Changes with wChanged
					EndDialog(hDlg, TRUE);		// Quit this dialog
					return TRUE;				// Indicate we handled this message
		} // End switch (wParam)
		break;

	case WM_CLOSE:
		EndDialog(hDlg, TRUE);				// Quit this dialog
		return TRUE;						// Indicate we handled this message

	} // End switch (message)

	return FALSE;								// Indicate we didn't handle this message
} // End of Programs()


//************************************************************************
//	BOOL CALLBACK _export SaveFile
//
//	Description:
//	Changes have been made to the .INI file and exit has been selected.
//	See if that's what the user really wants.
//************************************************************************

BOOL CALLBACK _export SaveFile(HWND hDlg,
				UINT message,
				WPARAM wParam,
				LPARAM lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
		CenterWindow(hDlg);	// Reposition the window to the center of the screen
		return TRUE;			// Use the focus in wParam

		case WM_COMMAND:
			// If the user pressed one of our buttons, ...
			switch (wParam)
			{
				case IDOK:
				case IDIGNORE:
				case IDCANCEL:
					EndDialog(hDlg, wParam);	// Quit this dialog, returning the IDC_xxx value
					return TRUE;	// Indicate we processed this message
			} // End switch (wParam)

			break;
	} // End switch (message)

	return FALSE;					// Indicate we didn't process this message
} // End of SaveFile()


//***************************************************************************
//	End of File: GOAHEAD.C
//***************************************************************************

